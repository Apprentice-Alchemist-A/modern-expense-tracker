# エラーログ 008 - 日付範囲選択のタイムゾーン問題

**日付**: 2025-06-22  
**発生時刻**: セッション継続中  
**重要度**: High  
**カテゴリ**: UI/タイムゾーン  

## エラー概要

日付範囲選択機能において、以下の複数の問題が発生：

1. **日付表示ずれ**: 選択した日付が1日前の日付として表示される
2. **プリセット選択の不整合**: プリセットで正しい範囲が選択されるが、表示が異なる
3. **カスタム範囲の挙動**: カスタム範囲選択後にプリセット画面が表示される

## 技術的詳細

### 根本原因
```typescript
// 問題のあったコード
const dateString = date.toISOString().split('T')[0]

// toISOString()はUTC時間を返すため、
// JST（UTC+9）環境では9時間の差でタイムゾーンずれが発生
```

### 具体的な問題パターン

#### 1. タイムゾーン変換エラー
- **現象**: 日本時間で2025-06-22を選択 → 2025-06-21として表示
- **原因**: `toISOString()`がUTC基準で日付を変換
- **影響**: 全ての日付操作（プリセット・カスタム選択）

#### 2. 状態管理の競合
- **現象**: カスタム範囲選択後にプリセット画面表示
- **原因**: `setShowCustom(false)`の不適切な呼び出し
- **影響**: UX品質の低下

#### 3. デバッグ情報の不整合
- **現象**: コンソールログが表示されない
- **原因**: ログ出力タイミングの問題
- **影響**: デバッグ作業の困難

## 解決方法

### 1. ローカル時間関数の導入
```typescript
// 修正後のコード
const formatDateLocal = (date: Date): string => {
  const year = date.getFullYear()
  const month = String(date.getMonth() + 1).padStart(2, '0')
  const day = String(date.getDate()).padStart(2, '0')
  return `${year}-${month}-${day}`
}
```

### 2. 全日付操作の統一
- プリセット計算でのタイムゾーン対応
- カスタム選択でのタイムゾーン対応
- 日付比較処理でのタイムゾーン対応

### 3. UI状態管理の修正
```typescript
// カスタム範囲をデフォルトに
onClick={() => {
  setIsOpen(!isOpen)
  if (!isOpen) {
    setShowCustom(true) // 必ずカスタム範囲表示
  }
}}
```

## 修正ファイル

### `/components/ui/DateRangePicker.tsx`
- `formatDateLocal()`関数の追加
- 全プリセット計算での`formatDateLocal()`使用
- `handleDateClick`での`formatDateLocal()`使用
- `isDateInRange`、`isDateSelected`での`formatDateLocal()`使用
- デバッグログの削除

### `/components/expenses/ExpenseFilters.tsx`
- デバッグログの削除
- 状態更新の最適化

## 影響範囲

### 修正前の問題
- **ユーザー体験**: 混乱を招く日付表示
- **データ整合性**: 間違った日付でのフィルタリング
- **開発効率**: デバッグの困難

### 修正後の改善
- **正確な日付表示**: 選択した日付がそのまま表示
- **一貫したUX**: カスタム範囲がデフォルト表示
- **クリーンなコード**: デバッグログの除去

## 再発防止策

### 1. 日付処理のベストプラクティス
- ローカル時間での一貫した処理
- `toISOString()`の慎重な使用
- タイムゾーンを考慮した設計

### 2. 状態管理の設計原則
- 単一責任の原則
- 副作用の最小化
- 予測可能な状態遷移

### 3. テスト戦略
- タイムゾーン別でのテスト
- 境界値でのテスト
- UX フローの検証

## 学習ポイント

1. **JavaScriptの日付処理**: `toISOString()`とローカル時間の違い
2. **React状態管理**: useEffect依存配列の重要性
3. **UXデザイン**: 一貫したインターフェース設計の重要性

この問題を通じて、フロントエンド開発におけるタイムゾーン処理の複雑さと、ユーザー体験に与える影響の大きさを再認識しました。